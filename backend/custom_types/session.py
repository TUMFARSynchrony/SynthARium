"""Provide the `SessionDict` TypedDict and related utility functions.

Use for type hints and static type checking without any overhead during runtime.
"""

from typing import Any
from typing_extensions import NotRequired, TypedDict

import custom_types.util as util

from custom_types.participant import ParticipantDict, is_valid_participant
from custom_types.note import NoteDict, is_valid_note


class SessionDict(TypedDict):
    """TypedDict for session configuration data.

    Attributes
    ----------
    id : str, optional
        Unique session id generated by the backend after saving the session.  When
        creating a new session, this field is initially left blank by the client.
        Read only for client.
    title : str
        Experiment title.
    description : str
        Experiment description.
    date : int
        Planned starting date / time of the experiment in milliseconds since January 1,
        1970, 00:00:00 (UTC).
    time_limit : int
        Experiment time limit in milliseconds since January 1, 1970, 00:00:00 (UTC).
    record : bool
        Whether the experiment is to be recorded.
    participants : list of custom_types.participant.ParticipantDict
        List of invited participants.
    start_time : int, optional
        Time the experiment started in milliseconds since January 1, 1970, 00:00:00
        (UTC).  Read only for client.
    end_time : int, optional
        Time the experiment ended in milliseconds since January 1, 1970, 00:00:00 (UTC).
        Read only for client.
    notes : list of custom_types.note.NoteDict
        List of `NoteDict`s the experimenter added during the experiment.  Read only for
        client.
    log : Any, optional
        Log created by the backend.  Read only for client.

    See Also
    --------
    Data Types Wiki :
        https://github.com/TUMFARSynchorny/experimental-hub/wiki/Data-Types#session
    """

    id: NotRequired[str]
    title: str
    description: str
    date: int
    time_limit: int
    record: bool
    participants: list[ParticipantDict]
    start_time: NotRequired[int]
    end_time: NotRequired[int]
    notes: list[NoteDict]
    log: NotRequired[Any]


def is_valid_session(data, recursive: bool) -> bool:
    """Check if `data` is a valid SessionDict.

    Checks if all required and only required or optional keys exist in data as well as
    the data type of the values.

    Parameters
    ----------
    data : any
        Data to perform check on.
    recursive : bool
        If true, participants and notes will be checked recursively.

    Returns
    -------
    bool
        True if `data` is a valid SessionDict.
    """
    if not util.check_valid_typeddict_keys(data, SessionDict):
        return False

    # Check participants and notes
    if not isinstance(data["participants"], list) or not isinstance(
        data["notes"], list
    ):
        return False

    if recursive:
        for entry in data["participants"]:
            if not is_valid_participant(entry, recursive):
                return False
        for entry in data["notes"]:
            if not is_valid_note(entry):
                return False

    # TODO check log

    # Check optional keys
    valid_id = "id" not in data or isinstance(data["id"], str)
    valid_start_time = "start_time" not in data or isinstance(data["start_time"], int)
    valid_end_time = "end_time" not in data or isinstance(data["end_time"], int)

    return (
        valid_id
        and valid_start_time
        and valid_end_time
        and isinstance(data["title"], str)
        and isinstance(data["description"], str)
        and isinstance(data["date"], int)
        and isinstance(data["time_limit"], int)
        and isinstance(data["record"], bool)
    )


def get_participant_ids(session_dict: SessionDict) -> list[str | None]:
    """Get all participant IDs from session_dict. Missing IDs will be None.

    Parameters
    ----------
    data : custom_types.session.SessionDict
        Session data with participants.

    Returns
    -------
    list of str and/or None
        Participant IDs in `session_dict` with None for missing/empty IDs.

    See Also
    --------
    get_filtered_participant_ids : Get IDs without None values for missing IDs.
    """
    return [p.get("id") for p in session_dict.get("participants", [])]


def get_filtered_participant_ids(session_dict: SessionDict) -> list[str]:
    """Get all participant IDs from session_dict. Missing IDs will be filtered out.

    Parameters
    ----------
    data : custom_types.session.SessionDict
        Session data with participants.

    Returns
    -------
    list of str
        Participant IDs in `session_dict` without missing/empty IDs.

    See Also
    --------
    get_participant_ids : Get IDs with None values for missing IDs.
    """
    p_ids = get_participant_ids(session_dict)
    return [id for id in p_ids if id is not None]


def has_duplicate_participant_ids(session_dict: SessionDict) -> bool:
    """Check if `session_dict` has duplicate session IDs.

    Parameters
    ----------
    session_dict : custom_types.session.SessionDict
        Session dictionary that should be checked for duplicates.

    Returns
    -------
    bool
        True if there are duplicate IDs, False if no duplicate IDs where found.
    """
    participant_ids = get_filtered_participant_ids(session_dict)
    return len(participant_ids) != len(set(participant_ids))
